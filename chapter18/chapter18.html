<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Shadows | 使用 LWJGL 3 开发 3D 游戏</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/3d-game-development-with-lwjgl/assets/css/0.styles.33e5fdc6.css" as="style"><link rel="preload" href="/3d-game-development-with-lwjgl/assets/js/app.519c1cc5.js" as="script"><link rel="preload" href="/3d-game-development-with-lwjgl/assets/js/2.e7870360.js" as="script"><link rel="preload" href="/3d-game-development-with-lwjgl/assets/js/27.4fa5cc0d.js" as="script"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/10.7296f99c.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/11.a42afaf0.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/12.b7fdae6a.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/13.01b80f30.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/14.06f37286.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/15.c4635c97.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/16.f4253e97.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/17.c7f6896c.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/18.8a24c215.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/19.ab6ce5f4.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/20.9046ed34.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/21.3cb4242e.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/22.b2fa78a0.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/23.a9e504af.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/24.12580511.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/25.a115cf89.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/26.7193040d.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/28.e559af67.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/29.d5befc6c.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/3.8fb1d8aa.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/30.ee00c5df.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/31.0effa8ac.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/32.c13100cf.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/33.c9fbfcdb.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/34.7bde7785.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/35.604c8847.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/36.ccd3a84c.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/37.ec274013.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/38.66d82b73.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/4.e1b9ee22.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/5.75c3f2db.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/6.601d5460.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/7.1f9c2020.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/8.be9c92d8.js"><link rel="prefetch" href="/3d-game-development-with-lwjgl/assets/js/9.048bb756.js">
    <link rel="stylesheet" href="/3d-game-development-with-lwjgl/assets/css/0.styles.33e5fdc6.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/3d-game-development-with-lwjgl/" class="home-link router-link-active"><!----> <span class="site-name">使用 LWJGL 3 开发 3D 游戏</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/3d-game-development-with-lwjgl/" aria-current="page" class="sidebar-link">封面</a></li><li><a href="/3d-game-development-with-lwjgl/INTRODUCTION.html" class="sidebar-link">简介</a></li><li><a href="/3d-game-development-with-lwjgl/chapter01/chapter1.html" class="sidebar-link">第一步</a></li><li><a href="/3d-game-development-with-lwjgl/chapter02/chapter2.html" class="sidebar-link">The Game Loop</a></li><li><a href="/3d-game-development-with-lwjgl/chapter03/chapter3.html" class="sidebar-link">A brief about coordinates</a></li><li><a href="/3d-game-development-with-lwjgl/chapter04/chapter4.html" class="sidebar-link">Rendering</a></li><li><a href="/3d-game-development-with-lwjgl/chapter05/chapter5.html" class="sidebar-link">More on Rendering</a></li><li><a href="/3d-game-development-with-lwjgl/chapter06/chapter6.html" class="sidebar-link">Transformations</a></li><li><a href="/3d-game-development-with-lwjgl/chapter07/chapter7.html" class="sidebar-link">Textures</a></li><li><a href="/3d-game-development-with-lwjgl/chapter08/chapter8.html" class="sidebar-link">Camera</a></li><li><a href="/3d-game-development-with-lwjgl/chapter09/chapter9.html" class="sidebar-link">Loading more complex models</a></li><li><a href="/3d-game-development-with-lwjgl/chapter10/chapter10.html" class="sidebar-link">Let there be light</a></li><li><a href="/3d-game-development-with-lwjgl/chapter11/chapter11.html" class="sidebar-link">Let there be even more light</a></li><li><a href="/3d-game-development-with-lwjgl/chapter12/chapter12.html" class="sidebar-link">Game HUD</a></li><li><a href="/3d-game-development-with-lwjgl/chapter13/chapter13.html" class="sidebar-link">Sky Box and some optimizations</a></li><li><a href="/3d-game-development-with-lwjgl/chapter14/chapter14.html" class="sidebar-link">Height Maps</a></li><li><a href="/3d-game-development-with-lwjgl/chapter15/chapter15.html" class="sidebar-link">Terrain Collisions</a></li><li><a href="/3d-game-development-with-lwjgl/chapter16/chapter16.html" class="sidebar-link">Fog</a></li><li><a href="/3d-game-development-with-lwjgl/chapter17/chapter17.html" class="sidebar-link">Normal Mapping</a></li><li><a href="/3d-game-development-with-lwjgl/chapter18/chapter18.html" aria-current="page" class="active sidebar-link">Shadows</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/3d-game-development-with-lwjgl/chapter18/chapter18.html#shadow-mapping" class="sidebar-link">Shadow Mapping</a></li><li class="sidebar-sub-header"><a href="/3d-game-development-with-lwjgl/chapter18/chapter18.html#shadow-mapping-improvements" class="sidebar-link">Shadow Mapping improvements</a></li></ul></li><li><a href="/3d-game-development-with-lwjgl/chapter19/chapter19.html" class="sidebar-link">Animations</a></li><li><a href="/3d-game-development-with-lwjgl/chapter20/chapter20.html" class="sidebar-link">Particles</a></li><li><a href="/3d-game-development-with-lwjgl/chapter21/chapter21.html" class="sidebar-link">Instanced Rendering</a></li><li><a href="/3d-game-development-with-lwjgl/chapter22/chapter22.html" class="sidebar-link">Audio</a></li><li><a href="/3d-game-development-with-lwjgl/chapter23/chapter23.html" class="sidebar-link">3D Object Picking</a></li><li><a href="/3d-game-development-with-lwjgl/chapter24/chapter24.html" class="sidebar-link">HUD Revisited - NanoVG</a></li><li><a href="/3d-game-development-with-lwjgl/chapter25/chapter25.html" class="sidebar-link">Optimizations - Frustum Culling \(I\)</a></li><li><a href="/3d-game-development-with-lwjgl/chapter26/chapter26.html" class="sidebar-link">Cascaded Shadow Maps</a></li><li><a href="/3d-game-development-with-lwjgl/chapter27/chapter27.html" class="sidebar-link">Assimp</a></li><li><a href="/3d-game-development-with-lwjgl/chapter28/chapter28.html" class="sidebar-link">Deferred Shading</a></li><li><a href="/3d-game-development-with-lwjgl/appendixa/appendixa.html" class="sidebar-link">Appendix A - OpenGL Debugging</a></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="shadows"><a href="#shadows" class="header-anchor">#</a> Shadows</h1> <h2 id="shadow-mapping"><a href="#shadow-mapping" class="header-anchor">#</a> Shadow Mapping</h2> <p>Currently we are able to represent how light affects the objects in a 3D scene. Objects that get more light are shown brighter than objects that do not receive light. However we are still not able to cast shadows. Shadows will increase the degree of realism of a 3D scene, so we will add support for it in this chapter.</p> <p>We will use a technique named Shadow mapping which is widely used in games and does not severely affect the engine performance. Shadow mapping may seem simple to understand but it’s somehow difficult to implement correctly. Or, to be more precise, it’s very difficult to implement it in a general way that covers all the potential cases and produces consistent results.</p> <p>We will explain here an approach which will allow you to add shadows for most of the cases but, what’s more important, it will serve you to understand its limitations. The code presented here is far from being perfect but I think it will be easy to understand. It is also designed to support directional lights (which in my opinion is the more complex case) but you will learn how it can be extended to support other type of lights (such as point lights). If you want to achieve more advanced results you should use more advance techniques such as Cascaded Shadow Maps. In any case, the concepts explained here will serve you as a basis.</p> <p>So let’s start by thinking how we could check if a specific area (indeed a fragment) is in shadow or not. While drawing that area if we can cast rays to the light source and reach the light source without any collision then that pixel is in light. If not, the pixel is in shadow.</p> <p>The following picture shows the case for a point light: point PA can reach the source light, but points PB and PC can’t so they are in shadow.</p> <p><img src="shadow_concepts_I.png" alt="Shadow Concepts I"></p> <p>How we can check in an efficient manner if we can cast that ray without collisions? A light source can theoretically cast infinitely ray lights, so how do we check if a ray light is blocked or not?
What we can do instead of casting ray lights is to look at the 3D scene from the light’s perspective and render the scene from that location. We can set the camera at the light position and render the scene so we can store the depth for each fragment. This is equivalent to calculate the distance of each fragment to the light source. At the end, what we are doing is storing the minimum distance as seen from the light source as a shadow map.</p> <p>The following picture shows a cube floating over a plane and  a perpendicular light.</p> <p><img src="shadow_concepts_II.png" alt="Shadow Concepts II"></p> <p>The scene as seen from the light perspective would be something like this (the darker the colour, the closer to the light source).</p> <p><img src="render_light_perspective.png" alt="Rendering from light perspective"></p> <p>With that information we can render the 3D scene as usual and check the distance for each fragment to the light source with the minimum stored distance. If the distance is less that the value stored in the shadow map, then the object is in light, otherwise it's in shadow. We can have several objects that could be hit by the same ray light, but we store the minimum distance.</p> <p>Thus, shadow mapping is a two step process:</p> <ul><li>First we render the scene from the light space into a shadow map to get the minimum distances.</li> <li>Second we render the scene from the camera point of view and use that depth  map to calculate if objects are in shadow or not.</li></ul> <p>In order to render the depth map we need to talk about the depth buffer. When we render a scene, all the depth information is stored in a buffer named, obviously, depth-buffer (or z-buffer). That depth information is the $$z$$ value of each of the fragment that is rendered. If you recall from the first chapters what we are doing while rendering a scene is transforming from world coordinates to screen coordinates. We are drawing to a coordinate space which ranges from $$0$$ to $$1$$ for $$x$$ and $$y$$ axis. If an object is more distant than another, we must calculate how this affects their $$x$$ and $$y$$ coordinates through the perspective projection matrix. This is not calculated automatically depending on the $$z$$ value, but must be done us. What is actually stored in the z coordinate is the depth of that fragment, nothing less and nothing more.</p> <p>Besides that, in our source code we need to enable depth testing. In the <code>Window</code> class we set the following line:</p> <div class="language-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token function">glEnable</span><span class="token punctuation">(</span>GL_DEPTH_TEST<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>By setting this line we prevent drawing fragments that cannot be seen, because they are behind other objects. Before a fragment is drawn its $$z$$ value is compared with the $$z$$ value of the z-buffer. If it has a higher $$z$$ value (it’s far away) than the $$z$$ value of the buffer is discarded. Remember that this is done in screen space, so we are comparing the $$z$$ value of a fragment given a pair of $$x$$ and $$y$$ coordinates in screen space, that is in the range $$[0, 1]$$. Thus, the $$z$$ value is also in that range.
The presence of the depth buffer is the reason why we need to clear the screen before performing any render operation. We need to clear not only the colour but also the depth information:</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">glClear</span><span class="token punctuation">(</span>GL_COLOR_BUFFER_BIT <span class="token operator">|</span> GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>In order to start building the depth map we want to get that depth information as viewed from the light perspective. We need to setup a camera in the light position, render the scene and store that depth information into a texture so we can access it later.</p> <p>Therefore, the first thing we need to do is add support for creating those textures.  We will modify the <code>Texture</code> class to support the creation of empty textures by adding a new constructor. This constructor expects the dimensions of the texture and the format of the pixels it stores.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">Texture</span><span class="token punctuation">(</span><span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">,</span> <span class="token keyword">int</span> pixelFormat<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token function">glGenTextures</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>width <span class="token operator">=</span> width<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>height <span class="token operator">=</span> height<span class="token punctuation">;</span>
    <span class="token function">glBindTexture</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glTexImage2D</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> GL_DEPTH_COMPONENT<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>width<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>height<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> pixelFormat<span class="token punctuation">,</span> GL_FLOAT<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">ByteBuffer</span><span class="token punctuation">)</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MIN_FILTER<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_MAG_FILTER<span class="token punctuation">,</span> GL_NEAREST<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_S<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">glTexParameteri</span><span class="token punctuation">(</span>GL_TEXTURE_2D<span class="token punctuation">,</span> GL_TEXTURE_WRAP_T<span class="token punctuation">,</span> GL_CLAMP_TO_EDGE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>We set the texture wrapping mode to <code>GL_CLAMP_TO_EDGE</code> since we do not want the texture to repeat in case we exceed the $$[0, 1]$$ range.</p> <p>So now that we are able to create empty textures, we need to be able to render a scene into it. In order to do that we need to use Frame Buffers Objects (or FBOs). A Frame Buffer is a collection of buffers that can be used as a destination for rendering. When we have been rendering to the screen we have using OpenGL’s default buffer. OpenGL allows us to render to user defined buffers by using FBOs. We will isolate the rest of the code of the process of creating FBOs for shadow mapping by creating a new class named <code>ShadowMap</code>. This is the definition of that class.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">package</span> <span class="token namespace">org<span class="token punctuation">.</span>lwjglb<span class="token punctuation">.</span>engine<span class="token punctuation">.</span>graph</span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">org<span class="token punctuation">.</span>lwjgl<span class="token punctuation">.</span>opengl<span class="token punctuation">.</span></span>GL11<span class="token punctuation">.</span>*<span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token keyword">static</span> <span class="token namespace">org<span class="token punctuation">.</span>lwjgl<span class="token punctuation">.</span>opengl<span class="token punctuation">.</span></span>GL30<span class="token punctuation">.</span>*<span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShadowMap</span> <span class="token punctuation">{</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHADOW_MAP_WIDTH <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHADOW_MAP_HEIGHT <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> depthMapFBO<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Texture</span> depthMap<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ShadowMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token comment">// Create a FBO to render the depth map</span>
        depthMapFBO <span class="token operator">=</span> <span class="token function">glGenFramebuffers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Create the depth map texture</span>
        depthMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Texture</span><span class="token punctuation">(</span>SHADOW_MAP_WIDTH<span class="token punctuation">,</span> SHADOW_MAP_HEIGHT<span class="token punctuation">,</span> GL_DEPTH_COMPONENT<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Attach the depth map texture to the FBO</span>
        <span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> depthMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">glFramebufferTexture2D</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> GL_DEPTH_ATTACHMENT<span class="token punctuation">,</span> GL_TEXTURE_2D<span class="token punctuation">,</span> depthMap<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Set only depth</span>
        <span class="token function">glDrawBuffer</span><span class="token punctuation">(</span>GL_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">glReadBuffer</span><span class="token punctuation">(</span>GL_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">glCheckFramebufferStatus</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">)</span> <span class="token operator">!=</span> GL_FRAMEBUFFER_COMPLETE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">&quot;Could not create FrameBuffer&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Unbind</span>
        <span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Texture</span> <span class="token function">getDepthMapTexture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> depthMap<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getDepthMapFBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> depthMapFBO<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">glDeleteFramebuffers</span><span class="token punctuation">(</span>depthMapFBO<span class="token punctuation">)</span><span class="token punctuation">;</span>
        depthMap<span class="token punctuation">.</span><span class="token function">cleanup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br></div></div><p>The <code>ShadowMap</code> class defines two constants that determine the size of the texture that will  hold the depth map. It also defines two attributes, one for the FBO and one for the texture. In the constructor, we create a new FBO and a new <code>Texture</code>. For the FBO we will use as the pixel format the constant <code>GL_DEPTH_COMPONENT</code> since we are only interested in storing depth values. Then we attach the FBO to the texture instance.</p> <p>The following lines explicitly set the FBO to not render any colour. A FBO needs a colour buffer, but we are not going to needed. This is why we set the colour buffers to be used as <code>GL_NONE</code>.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">glDrawBuffer</span><span class="token punctuation">(</span>GL_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glReadBuffer</span><span class="token punctuation">(</span>GL_NONE<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Now we are ready to render the scene from the light perspective into FBO in the <code>Renderer</code> class. In order to do that, we will create a specific set of vertex and fragments shaders.</p> <p>The vertex shader, named <code>depth_vertex.fs</code>, is defined like this.</p> <div class="language-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span></span></span>

<span class="token keyword">layout</span> <span class="token punctuation">(</span>location<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> position<span class="token punctuation">;</span>
<span class="token keyword">layout</span> <span class="token punctuation">(</span>location<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> texCoord<span class="token punctuation">;</span>
<span class="token keyword">layout</span> <span class="token punctuation">(</span>location<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> vertexNormal<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> modelLightViewMatrix<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> orthoProjectionMatrix<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    gl_Position <span class="token operator">=</span> orthoProjectionMatrix <span class="token operator">*</span> modelLightViewMatrix <span class="token operator">*</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>We expect to receive the same input data as the scene shader. In fact, we only need the position, but to reuse as much as code as possible we will pass it anyway. We also need a pair of matrices. Remember that we must render the scene from the light point of view, so we need to transform our models to the light's coordinate space. This is done through the <code>modelLightViewMatrix</code> matrix, which is analogous to view model matrix used for a camera. The light is our camera now.</p> <p>Then we need to transform those coordinates to screen space, that is, we need to project them. And this is one of the differences while calculating shadow maps for directional lights versus point lights. For point lights we would use a perspective projection matrix as if we were rendering the scene normally. Directional lights, instead, affect all objects in the same way independently of the distance. Directional lights are located at an infinite point and do not have a position but a direction. An orthographic projection does not render distant objects smaller, and because of this characteristic is the most suitable for directional lights.</p> <p>The fragment shader is even simpler. It just outputs the $$z$$ coordinate as the depth value.</p> <div class="language-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span></span></span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    gl_FragDepth <span class="token operator">=</span> gl_FragCoord<span class="token punctuation">.</span>z<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>In fact, you can remove that line, since we are only generating depth values, the depth value it will be automatically returned.</p> <p>Once we have defined the new shaders for depth rendering we can use them in the <code>Renderer</code> class. We define a new method for setting up those shaders, named <code>setupDepthShader</code>, which will be invoked where the others shaders are initialized.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setupDepthShader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    depthShaderProgram <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ShaderProgram</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    depthShaderProgram<span class="token punctuation">.</span><span class="token function">createVertexShader</span><span class="token punctuation">(</span><span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">loadResource</span><span class="token punctuation">(</span><span class="token string">&quot;/shaders/depth_vertex.vs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    depthShaderProgram<span class="token punctuation">.</span><span class="token function">createFragmentShader</span><span class="token punctuation">(</span><span class="token class-name">Utils</span><span class="token punctuation">.</span><span class="token function">loadResource</span><span class="token punctuation">(</span><span class="token string">&quot;/shaders/depth_fragment.fs&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    depthShaderProgram<span class="token punctuation">.</span><span class="token function">link</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    depthShaderProgram<span class="token punctuation">.</span><span class="token function">createUniform</span><span class="token punctuation">(</span><span class="token string">&quot;orthoProjectionMatrix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    depthShaderProgram<span class="token punctuation">.</span><span class="token function">createUniform</span><span class="token punctuation">(</span><span class="token string">&quot;modelLightViewMatrix&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Now we need to create a new method that uses those shaders which will be named <code>renderDepthMap</code>. This method will be invoked in the principal render method.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">render</span><span class="token punctuation">(</span><span class="token class-name">Window</span> window<span class="token punctuation">,</span> <span class="token class-name">Camera</span> camera<span class="token punctuation">,</span> <span class="token class-name">Scene</span> scene<span class="token punctuation">,</span> <span class="token class-name">IHud</span> hud<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Render depth map before view ports has been set up</span>
    <span class="token function">renderDepthMap</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> camera<span class="token punctuation">,</span> scene<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Rest of the code here ....</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>If you look at the code above, you will see that the new method is invoked at the very beginning, before we have set the view port. This is due to the fact that this new method will change the view port to match the dimensions of the texture that holds the depth map. Because of that, we will always need to set, after the <code>renderDepthMap</code> has been finished, the view port to the screen dimensions (without checking if the window has been resized).</p> <p>Let’s define now the <code>renderDepthMap</code> method. The first thing that we will do is to bind to the FBO we have created in the <code>ShadowMap</code> class and set the view port to match the texture dimensions.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> shadowMap<span class="token punctuation">.</span><span class="token function">getDepthMapFBO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glViewport</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token class-name">ShadowMap</span><span class="token punctuation">.</span>SHADOW_MAP_WIDTH<span class="token punctuation">,</span> <span class="token class-name">ShadowMap</span><span class="token punctuation">.</span>SHADOW_MAP_HEIGHT<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Then we clear the depth buffer contents and bind the depth shaders. Since we are only dealing with depth values we do not need to clear colour information.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token function">glClear</span><span class="token punctuation">(</span>GL_DEPTH_BUFFER_BIT<span class="token punctuation">)</span><span class="token punctuation">;</span>

depthShaderProgram<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Now we need to setup the matrices, and here comes the tricky part. We use the light as a camera so we need to create a view matrix which needs a position and three angles. As it has been said at the beginning of the chapter we will support  only directional lights, and that type of lights does not define a position but a direction. If we were using point lights this would be easy, the position of the light would be the position of the view matrix, but we do not have that.</p> <p>We will take a simple approach to calculate the light position. Directional lights are defined by a vector, usually, normalized, which points to the direction where the light is. We will multiply that direction vector by a configurable factor so it defines a point at a reasonable distance for the scene we want to draw. We will use that direction in order to calculate the rotation angle for that view matrix.</p> <p><img src="light_position.png" alt="Light position"></p> <p>This is the fragment that calculates the light position and the rotation angles</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">float</span> lightAngleX <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">acos</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> lightAngleY <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">asin</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> lightAngleZ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token class-name">Matrix4f</span> lightViewMatrix <span class="token operator">=</span> transformation<span class="token punctuation">.</span><span class="token function">updateLightViewMatrix</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Vector3f</span><span class="token punctuation">(</span>lightDirection<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mul</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span><span class="token function">getShadowPosMult</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Vector3f</span><span class="token punctuation">(</span>lightAngleX<span class="token punctuation">,</span> lightAngleY<span class="token punctuation">,</span> lightAngleZ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Next we need to calculate the orthographic projection matrix.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">Matrix4f</span> orthoProjMatrix <span class="token operator">=</span> transformation<span class="token punctuation">.</span><span class="token function">updateOrthoProjectionMatrix</span><span class="token punctuation">(</span>orthCoords<span class="token punctuation">.</span>left<span class="token punctuation">,</span> orthCoords<span class="token punctuation">.</span>right<span class="token punctuation">,</span> orthCoords<span class="token punctuation">.</span>bottom<span class="token punctuation">,</span> orthCoords<span class="token punctuation">.</span>top<span class="token punctuation">,</span> orthCoords<span class="token punctuation">.</span>near<span class="token punctuation">,</span> orthCoords<span class="token punctuation">.</span>far<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>We have modified the <code>Transformation</code> class to include the light view matrix and the orthographic projection matrix. Previously we had an orthographic 2D projection matrix, so we have renamed the previous methods and attributes. You can check the definition in the source code which is straightforward.</p> <p>Then we render the scene objects as in the <code>renderScene</code> method but using the previous matrices to work in light space coordinate system.</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code>depthShaderProgram<span class="token punctuation">.</span><span class="token function">setUniform</span><span class="token punctuation">(</span><span class="token string">&quot;orthoProjectionMatrix&quot;</span><span class="token punctuation">,</span> orthoProjMatrix<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Mesh</span><span class="token punctuation">,</span> <span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">GameItem</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> mapMeshes <span class="token operator">=</span> scene<span class="token punctuation">.</span><span class="token function">getGameMeshes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Mesh</span> mesh <span class="token operator">:</span> mapMeshes<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mesh<span class="token punctuation">.</span><span class="token function">renderList</span><span class="token punctuation">(</span>mapMeshes<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>mesh<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">GameItem</span> gameItem<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
        <span class="token class-name">Matrix4f</span> modelLightViewMatrix <span class="token operator">=</span> transformation<span class="token punctuation">.</span><span class="token function">buildModelViewMatrix</span><span class="token punctuation">(</span>gameItem<span class="token punctuation">,</span> lightViewMatrix<span class="token punctuation">)</span><span class="token punctuation">;</span>
        depthShaderProgram<span class="token punctuation">.</span><span class="token function">setUniform</span><span class="token punctuation">(</span><span class="token string">&quot;modelLightViewMatrix&quot;</span><span class="token punctuation">,</span> modelLightViewMatrix<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// Unbind</span>
depthShaderProgram<span class="token punctuation">.</span><span class="token function">unbind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">glBindFramebuffer</span><span class="token punctuation">(</span>GL_FRAMEBUFFER<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>The parameterization of the orthographic projection matrix is defined in the directional Light. Think of the orthographic projection matrix as a bounding box that contains all the objects that we want to render. When projecting only the objects that fit into that bounding box will be be visible. That bounding box is defined by 6  parameters:  left, right, bottom, top, near, far. Since the light position is now the origin, these parameters define the distance from that origin to the left or right (x-axis) up or down (y-axis) and to the nearest or farthest plane (z-axis).</p> <p>One of the trickiest points in getting shadows map to work is determining the light position and the orthographic projection matrix parameters. This is why all these parameters are now defined in the <code>DirectionalLight</code> class so they can be set properly according to each scene.</p> <p>You can implement a more automatic approach by calculating the centre of the camera frustum, get back in the light direction and build an orthographic projection that contains all the objects in the scene. The following figure shows a 3D scene as looked from above, the camera position and its frustum (in blue) and the optimal light position and bounding box in red.</p> <p><img src="generic_light_pos_calculation.png" alt="Generic Light position calculation"></p> <p>The problem with the approach above is that it's difficult to calculate, and if you have small objects and the bounding box is big you may get strange results. The approach presented here is simpler for small scenes and you can tweak it to match your models (you can even chose to explicitly set light’s position to avoid strange effects if camera moves far away from the origin). If you want a more generic model that can be applied to any scene you should extend it to support cascading shadow maps.</p> <p>Let's continue. Before we use the depth maps to actually calculate shadows, you could render a quad with the generated texture to see how  a real depth map looks like. You could get something like this for a scene composed by a rotating cube floating over a plane with a perpendicular directional light.</p> <p><img src="depth_map.png" alt="Depth map"></p> <p>As we said before, the darker the colour, the closer to the light position. What’s the effect of the light position in the depth map? You can play with the multiplication factor of the directional light and you will see that the size of the objects rendered in the texture do not decrease. Remember that we are using an orthographic projection matrix and objects do not get smaller with distance. What you will see is that all colours get brighter as seen in the next picture.</p> <p><img src="depth_map_higher_distance.png" alt="Depth map at a higher distance"><br>
Does that mean that we can choose a high distance for the light position without consequences? The answer is no. If the light is too far away from the objects we want to render, these objects can be out of the bounding box that defines the orthographic projection matrix. In this case you will get a white texture which would be useless for shadow mapping. But if we simply increase the bounding box size, then everything will be OK, right? The answer is again no. If you chose huge dimensions for the orthographic projection matrix your objects will be drawn very small in the texture, and the depth values can even overlap leading to strange results. OK, so you can think in increasing the texture size, but, again in this case you are limited and textures cannot grow indefinitely to use huge bounding boxes.</p> <p>So as you can see, selecting the light position and the orthographic projection parameters is a complex equilibrium which makes it difficult to get right results using shadow mapping.</p> <p>Let’s go back to the rendering process. Once we have calculated the depth map we can use it while rendering the scene. First we need to modify the scene vertex shader. Up to now, the vertex shader  projected the vertex coordinates from model view space to the screen space using a perspective matrix. Now we need to project also the vertex coordinates from light space coordinates using a projection matrix to be used in the fragment shader to calculate the shadows.</p> <p>The vertex shader is modified like this.</p> <div class="language-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">version</span> <span class="token expression"><span class="token number">330</span></span></span>

<span class="token keyword">layout</span> <span class="token punctuation">(</span>location<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> position<span class="token punctuation">;</span>
<span class="token keyword">layout</span> <span class="token punctuation">(</span>location<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec2</span> texCoord<span class="token punctuation">;</span>
<span class="token keyword">layout</span> <span class="token punctuation">(</span>location<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token keyword">vec3</span> vertexNormal<span class="token punctuation">;</span>

<span class="token keyword">out</span> <span class="token keyword">vec2</span> outTexCoord<span class="token punctuation">;</span>
<span class="token keyword">out</span> <span class="token keyword">vec3</span> mvVertexNormal<span class="token punctuation">;</span>
<span class="token keyword">out</span> <span class="token keyword">vec3</span> mvVertexPos<span class="token punctuation">;</span>
<span class="token keyword">out</span> <span class="token keyword">vec4</span> mlightviewVertexPos<span class="token punctuation">;</span>
<span class="token keyword">out</span> <span class="token keyword">mat4</span> outModelViewMatrix<span class="token punctuation">;</span>

<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> modelViewMatrix<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> projectionMatrix<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> modelLightViewMatrix<span class="token punctuation">;</span>
<span class="token keyword">uniform</span> <span class="token keyword">mat4</span> orthoProjectionMatrix<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">vec4</span> mvPos <span class="token operator">=</span> modelViewMatrix <span class="token operator">*</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    gl_Position <span class="token operator">=</span> projectionMatrix <span class="token operator">*</span> mvPos<span class="token punctuation">;</span>
    outTexCoord <span class="token operator">=</span> texCoord<span class="token punctuation">;</span>
    mvVertexNormal <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>modelViewMatrix <span class="token operator">*</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>vertexNormal<span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>
    mvVertexPos <span class="token operator">=</span> mvPos<span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>
    mlightviewVertexPos <span class="token operator">=</span> orthoProjectionMatrix <span class="token operator">*</span> modelLightViewMatrix <span class="token operator">*</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>position<span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    outModelViewMatrix <span class="token operator">=</span> modelViewMatrix<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p>We use new uniforms for the light view matrix and the orthographic projection matrix.</p> <p>In the fragment shader we will create a new function to calculate the shadows that is defined like this.</p> <div class="language-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token keyword">float</span> <span class="token function">calcShadow</span><span class="token punctuation">(</span><span class="token keyword">vec4</span> position<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> shadowFactor <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>
    <span class="token keyword">vec3</span> projCoords <span class="token operator">=</span> position<span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>
    <span class="token comment">// Transform from screen coordinates to texture coordinates</span>
    projCoords <span class="token operator">=</span> projCoords <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> projCoords<span class="token punctuation">.</span>z <span class="token operator">&lt;</span> <span class="token function">texture</span><span class="token punctuation">(</span>shadowMap<span class="token punctuation">,</span> projCoords<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">.</span>r <span class="token punctuation">)</span> 
    <span class="token punctuation">{</span>
        <span class="token comment">// Current fragment is not in shade</span>
        shadowFactor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">1</span> <span class="token operator">-</span> shadowFactor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>The function receives the position in light view space projected using the orthographic projection matrix. It returns $$0$$ if the position is in shadow and $$1$$ if it’s not. First, the coordinates are transformed to texture coordinates. Screen coordinates are in the range $$[-1, 1$$], but texture coordinates are in the range $$[0, 1]$$. With those coordinates we get the depth value from the texture and compare it with the $$z$$ value of the fragment coordinates. If the $$z$$ value if the fragment has a lower value than the one stored in the texture, it means that the fragment is not in shade.</p> <p>In the fragment shader, the return value from the <code>calcShadow</code> function is used to modulate the light colour contributions from point, spot and directional lights. The ambient light is not affected by the shadow.</p> <div class="language-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token keyword">float</span> shadow <span class="token operator">=</span> <span class="token function">calcShadow</span><span class="token punctuation">(</span>mlightviewVertexPos<span class="token punctuation">)</span><span class="token punctuation">;</span>
fragColor <span class="token operator">=</span> <span class="token function">clamp</span><span class="token punctuation">(</span>ambientC <span class="token operator">*</span> <span class="token keyword">vec4</span><span class="token punctuation">(</span>ambientLight<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> diffuseSpecularComp <span class="token operator">*</span> shadow<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>In the <code>renderScene</code> method of the <code>Renderer</code> class we need to pass the uniform for the orthographic projection and light view matrices (we need to modify also the method that initializes the shader to create the new uniforms). You can consult this in the book’s source code.</p> <p>If you run the <code>DummyGame</code> class, which has been modified to setup a floating cube over a plane with a directional light the angle of which can be changed by using up and down keys, you should see something like this.</p> <p><img src="shadow_map_result.png" alt="Shadow Map result"></p> <p>Although shadows are working (you can check that by changing the light direction), the implementation presents some problems. First of all, there are strange lines in the objects that are lightened up. This effect is called shadow acne, and it’s produced by the limited resolution of the texture that stores the depth map. The second problem is that the borders of the shadow are not smooth and look blocky. The cause is the same again, the texture resolution. We will solve these problems in order to improve shadow quality.</p> <h2 id="shadow-mapping-improvements"><a href="#shadow-mapping-improvements" class="header-anchor">#</a> Shadow Mapping improvements</h2> <p>Now that we have the shadow mapping mechanism working, let’s solve the problems we have. Let’s first start with the shadow acne problem. The depth map texture is limited in size, and because of that, several fragments can be mapped to the same pixel in that texture depth. The texture depth stores the minimum depth, so at the end, we have several fragments that share the same depth in that texture although they are at different distances.</p> <p>We can solve this by adding a small bias to the depth comparison in the fragment shader.</p> <div class="language-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token keyword">float</span> bias <span class="token operator">=</span> <span class="token number">0.05</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> projCoords<span class="token punctuation">.</span>z <span class="token operator">-</span> bias <span class="token operator">&lt;</span> <span class="token function">texture</span><span class="token punctuation">(</span>shadowMap<span class="token punctuation">,</span> projCoords<span class="token punctuation">.</span>xy<span class="token punctuation">)</span><span class="token punctuation">.</span>r <span class="token punctuation">)</span> 
<span class="token punctuation">{</span>
    <span class="token comment">// Current fragment is not in shade</span>
    shadowFactor <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Now, the shadow acne has disappeared.</p> <p><img src="shadow_no_acne.png" alt="Shadow without acne"></p> <p>Next we are going to solve the shadow edges problem, which is also caused by the texture resolution. For each fragment we are going to sample the depth texture with the fragment’s position value and the surrounding values. Then we will calculate the average and assign that value as the shadow value. In this case its value won’t be $$0$$ or $$1$$ but can take values in between in order to get smoother edges.</p> <p><img src="depth_average_value.png" alt="Depth average value"></p> <p>The surrounding values must be at one pixel distance of the current fragment position in texture coordinates.  So we need to calculate the increment of one pixel in texture coordinates which is equal to $$1 / textureSize$$.</p> <p>In the fragment Shader we just need to modify the shadow factor calculation to get an average value.</p> <div class="language-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token keyword">float</span> shadowFactor <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span>
<span class="token keyword">vec2</span> inc <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token function">textureSize</span><span class="token punctuation">(</span>shadowMap<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> row <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> row <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>row<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> col <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> col <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>col<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">float</span> textDepth <span class="token operator">=</span> <span class="token function">texture</span><span class="token punctuation">(</span>shadowMap<span class="token punctuation">,</span> projCoords<span class="token punctuation">.</span>xy <span class="token operator">+</span> <span class="token keyword">vec2</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token operator">*</span> inc<span class="token punctuation">)</span><span class="token punctuation">.</span>r<span class="token punctuation">;</span> 
        shadowFactor <span class="token operator">+=</span> projCoords<span class="token punctuation">.</span>z <span class="token operator">-</span> bias <span class="token operator">&gt;</span> textDepth <span class="token operator">?</span> <span class="token number">1.0</span> <span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">;</span>        
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
shadowFactor <span class="token operator">/=</span> <span class="token number">9.0</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>The result looks now smoother.</p> <p><img src="final_result.png" alt="Final result"></p> <p>Now our sample looks much better. Nevertheless, the shadow mapping technique presented here can still be improved a lot. You can check about solving the peter panning effect (caused by the bias factor) and other techniques to improve the shadow edges. In any case, with the concepts explained here you have a good basis to start modifying the sample code.</p> <p>In order to render multiple lights you just need to  render a separate depth map for each light source. While rendering the scene you will need to sample all those depth maps to calculate the appropriate shadow factor.</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/CraftStarStudio/wjglbook-bookcontents-zh_CN/edit/master/chapter18/chapter18.md" target="_blank" rel="noopener noreferrer">帮助我们完善这个页面</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <div class="last-updated"><span class="prefix">最后更新 :</span> <span class="time">6/27/2021, 1:14:09 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/3d-game-development-with-lwjgl/chapter17/chapter17.html" class="prev">
        Normal Mapping
      </a></span> <span class="next"><a href="/3d-game-development-with-lwjgl/chapter19/chapter19.html">
        Animations
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/3d-game-development-with-lwjgl/assets/js/app.519c1cc5.js" defer></script><script src="/3d-game-development-with-lwjgl/assets/js/2.e7870360.js" defer></script><script src="/3d-game-development-with-lwjgl/assets/js/27.4fa5cc0d.js" defer></script>
  </body>
</html>
